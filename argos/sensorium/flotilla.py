"""Pimoroni Flotilla dock serial driver.

Opens the USB serial port to the Flotilla dock and reads module updates
in a background thread, storing typed sensor readings accessible at any
time via thread-safe properties.

Supported modules
-----------------
motion  — LSM303D 3-axis accelerometer + 3-axis magnetometer
weather — temperature + pressure (BMP085/BMP180)
colour  — RGBC (TCS34725)

Usage::

    reader = FlotillaReader()
    reader.start()

    m = reader.motion       # MotionReading or None
    w = reader.weather      # WeatherReading or None
    c = reader.colour       # ColourReading or None

    reader.close()

Two Motion modules are supported; the first seen on the dock becomes
`.motion`, the second (shoulder-link accelerometer/compass) becomes
`.motion2`.

Scale factors
-------------
Raw integer values are stored exactly as the firmware sends them.
Nominal conversions are provided as properties once the scale has been
confirmed against hardware readings — see WeatherReading.temperature_c
and WeatherReading.pressure_hpa.  Motion scale is marked TODO until
confirmed.
"""

from __future__ import annotations

import glob
import logging
import threading
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional

import serial

log = logging.getLogger(__name__)

_BAUD = 115200
_READ_TIMEOUT = 0.1   # seconds — short so the loop stays responsive


# ---------------------------------------------------------------------------
# Reading dataclasses
# ---------------------------------------------------------------------------

@dataclass
class MotionReading:
    """Raw LSM303D readings from a Flotilla Motion module.

    Values are raw integer counts as sent by the Flotilla firmware.
    With the board flat and gravity along +Z, acc_z will be a large
    positive value; acc_x and acc_y will be near zero.

    Scale factors (to convert to g / gauss) are TBC from hardware
    readings — run tests/test_flotilla.py and observe.
    """
    acc_x: int = 0
    acc_y: int = 0
    acc_z: int = 0
    mag_x: int = 0
    mag_y: int = 0
    mag_z: int = 0
    timestamp: float = field(default_factory=time.monotonic)


@dataclass
class WeatherReading:
    """Raw readings from a Flotilla Weather module.

    temperature_raw: tenths of °C (e.g. 215 → 21.5 °C)
    pressure_raw:    Pascals      (e.g. 101325 → 1013.25 hPa)

    Use .temperature_c and .pressure_hpa for converted values.
    Confirm the pressure scale against a known reading if needed.
    """
    temperature_raw: int = 0
    pressure_raw: int = 0
    timestamp: float = field(default_factory=time.monotonic)

    @property
    def temperature_c(self) -> float:
        return self.temperature_raw / 10.0

    @property
    def pressure_hpa(self) -> float:
        return self.pressure_raw / 100.0


@dataclass
class ColourReading:
    """Raw RGBC counts from a Flotilla Colour module (TCS34725)."""
    red: int = 0
    green: int = 0
    blue: int = 0
    clear: int = 0
    timestamp: float = field(default_factory=time.monotonic)


# ---------------------------------------------------------------------------
# Module parsers
# ---------------------------------------------------------------------------

def _parse_motion(data: str) -> MotionReading:
    v = [int(x) for x in data.split(",")]
    return MotionReading(
        acc_x=v[0], acc_y=v[1], acc_z=v[2],
        mag_x=v[3], mag_y=v[4], mag_z=v[5],
        timestamp=time.monotonic(),
    )


def _parse_weather(data: str) -> WeatherReading:
    v = [int(x) for x in data.split(",")]
    return WeatherReading(
        temperature_raw=v[0],
        pressure_raw=v[1],
        timestamp=time.monotonic(),
    )


def _parse_colour(data: str) -> ColourReading:
    v = [int(x) for x in data.split(",")]
    return ColourReading(
        red=v[0], green=v[1], blue=v[2], clear=v[3],
        timestamp=time.monotonic(),
    )


_PARSERS = {
    "motion":  _parse_motion,
    "weather": _parse_weather,
    "colour":  _parse_colour,
}


# ---------------------------------------------------------------------------
# Port detection
# ---------------------------------------------------------------------------

def _find_flotilla_port() -> Optional[str]:
    """Return the first /dev/ttyACM* device, or None."""
    candidates = sorted(glob.glob("/dev/ttyACM*"))
    return candidates[0] if candidates else None


# ---------------------------------------------------------------------------
# Main class
# ---------------------------------------------------------------------------

class FlotillaReader:
    """Background reader for a Pimoroni Flotilla dock.

    Spawns a daemon thread that continuously reads module updates from
    the dock's USB serial port and stores the latest reading for each
    module type.  All public properties are thread-safe.

    Parameters
    ----------
    port:
        Serial device path (e.g. ``/dev/ttyACM0``).  Auto-detected
        from ``/dev/ttyACM*`` if not given.
    """

    def __init__(self, port: Optional[str] = None):
        resolved = port or _find_flotilla_port()
        if not resolved:
            raise RuntimeError(
                "Flotilla dock not found — is it plugged in? "
                "Expected /dev/ttyACM* to exist."
            )
        self._serial = serial.Serial(resolved, _BAUD, timeout=_READ_TIMEOUT)
        log.info("Flotilla dock opened on %s", resolved)

        self._lock = threading.Lock()

        # Up to 2 Motion modules, assigned by channel as updates arrive
        self._motion: List[Optional[MotionReading]] = [None, None]
        self._motion_ch: List[Optional[int]] = [None, None]

        self._weather: Optional[WeatherReading] = None
        self._colour: Optional[ColourReading] = None

        self._modules: Dict[int, str] = {}   # channel → module_type

        self._thread = threading.Thread(
            target=self._loop, daemon=True, name="FlotillaReader"
        )
        self._running = False

    # --- lifecycle ----------------------------------------------------------

    def start(self) -> "FlotillaReader":
        """Start the background reader thread.  Returns self for chaining."""
        self._running = True
        self._thread.start()
        return self

    def close(self):
        """Stop the reader thread and close the serial port."""
        self._running = False
        if self._thread.is_alive():
            self._thread.join(timeout=2.0)
        if self._serial.is_open:
            self._serial.close()
        log.info("FlotillaReader closed")

    # --- sensor properties --------------------------------------------------

    @property
    def motion(self) -> Optional[MotionReading]:
        """First Motion module (dock channel order), or None."""
        with self._lock:
            return self._motion[0]

    @property
    def motion2(self) -> Optional[MotionReading]:
        """Second Motion module (shoulder-link LSM303D), or None."""
        with self._lock:
            return self._motion[1]

    @property
    def weather(self) -> Optional[WeatherReading]:
        """Latest WeatherReading, or None."""
        with self._lock:
            return self._weather

    @property
    def colour(self) -> Optional[ColourReading]:
        """Latest ColourReading, or None."""
        with self._lock:
            return self._colour

    @property
    def connected_modules(self) -> Dict[int, str]:
        """Dict of channel → module_type for all modules the dock has reported."""
        with self._lock:
            return dict(self._modules)

    # --- private ------------------------------------------------------------

    def _loop(self):
        while self._running:
            try:
                raw = self._serial.readline()
            except serial.SerialException as exc:
                log.error("FlotillaReader serial error: %s", exc)
                break
            if not raw:
                continue
            line = raw.decode("ascii", errors="replace").strip()
            if not line:
                continue
            try:
                self._dispatch(line)
            except Exception as exc:
                log.debug("FlotillaReader parse error on %r: %s", line, exc)

    def _dispatch(self, line: str):
        if line.startswith("u "):
            self._on_update(line[2:])
        elif line.startswith(("c ", "C ")):
            self._on_connect(line[2:])
        elif line.startswith(("d ", "D ")):
            self._on_disconnect(line[2:])
        # '#' info lines, 'v' version lines: silently ignored

    def _on_connect(self, rest: str):
        parts = rest.split()
        if len(parts) < 2:
            return
        ch, mod = int(parts[0]), parts[1]
        with self._lock:
            self._modules[ch] = mod
        log.info("Flotilla: %-12s connected on channel %d", mod, ch)

    def _on_disconnect(self, rest: str):
        parts = rest.split()
        if not parts:
            return
        ch = int(parts[0])
        with self._lock:
            mod = self._modules.pop(ch, "?")
            for i, mch in enumerate(self._motion_ch):
                if mch == ch:
                    self._motion[i] = None
                    self._motion_ch[i] = None
        log.info("Flotilla: channel %d (%s) disconnected", ch, mod)

    def _on_update(self, rest: str):
        # rest = "<channel> <module_type> <csv_data>"
        parts = rest.split(" ", 2)
        if len(parts) < 3:
            return
        ch, mod_type, data = int(parts[0]), parts[1], parts[2]

        parser = _PARSERS.get(mod_type)
        if parser is None:
            return

        try:
            reading = parser(data)
        except (ValueError, IndexError):
            return

        with self._lock:
            if mod_type == "motion":
                # Assign channel to a slot on first sight
                if ch not in self._motion_ch:
                    slot = next(
                        (i for i, v in enumerate(self._motion_ch) if v is None),
                        None,
                    )
                    if slot is not None:
                        self._motion_ch[slot] = ch
                        log.info(
                            "Motion module on channel %d → slot %d", ch, slot
                        )
                try:
                    self._motion[self._motion_ch.index(ch)] = reading
                except ValueError:
                    pass   # all slots taken, extra module ignored
            elif mod_type == "weather":
                self._weather = reading
            elif mod_type == "colour":
                self._colour = reading
